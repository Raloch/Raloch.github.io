{"pages":[],"posts":[{"title":"React Native简介","text":"1.React Native简介&emsp;&emsp;React Native（简称RN）是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架React在原生移动应用平台的衍生产物，支持安卓和IOS两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需要很少的学习就可以进入移动应用开发领域。 2.React Native特性&emsp;&emsp;React Native使你能够在Javascript和React的基础上获得完全一致的开发体验，创建出世界一流的原生App。&emsp;&emsp;React Native着力于提高多平台的开发效率，只需要一次性的学习，就可以编写兼容任何平台的App。 &emsp;1）原生的IOS组件 &emsp;&emsp;React Native主张“Learn once, write everywhere”而非其他跨平台工具一直宣扬的“Write once, run everywhere”。通过React Native，开发者可以使用UITabBar、UINavigationController等标准的IOS平台组件，让应用界面在其他平台上亦能保持始终如一的外观、风格。 &emsp;2）异步执行 &emsp;&emsp;JavaScript应用代码和原生平台之间所有的操作都采用异步执行模式，原生模块使用额外线程，开发者可以解码主线程图像、后台保存至磁盘、无须顾忌UI等诸多因素直接度量文本设计布局。 &emsp;3）触摸处理 &emsp;&emsp;React Native引入了一个类似于IOS上Responder Chain响应链事件处理机制的响应体系，并基于此为开发者提供了诸如TouchableHighlight等更高级的组件。 12345import {TouchableOpacity, Text} from 'react-native';&lt;TouchableOpacity activeOpacity={0.8} onPress={() =&gt; {}}&gt; &lt;Text&gt;提交&lt;/Text&gt;&lt;/TouchableOpacity&gt; 3.React Native入手&emsp;&emsp;前面我们阐述的一些关于的React Native的一些基本信息，现在我们主要来介绍React Native的入门介绍，让大家感受下React Native对于开发App的便利。 &emsp;1）构建React Native项目 &emsp;&emsp;安装RN脚手架，并使用脚手架构建项目 123npm install -g react-native-clireact-native init AwesomeProject &emsp;&emsp;生成的目录结构如下图： &emsp;&emsp;&emsp;&emsp; &emsp;&emsp;接着我们需要安装Android Studio软件，使用它来编译构建项目，其次就是它的模拟器功能，当然我们也可以使用自己的android手机。 &emsp;2）","link":"/2019/11/24/react-native/"},{"title":"react中如何自定义配置tradingView数据","text":"&emsp;&emsp;tradingView（以下简称为Tv）是当下交易所实现K线功能不可或缺的工具。但是其官方教程文档写的不够详细，导致本人在进行自定义数据配置时遇到一些困难。在此，我将该过程中的难点分享出来，希望大家看完能有效迅速的将其应用到你的项目中。完整实例地址 1.获取tradingView权限文件&emsp;&emsp;在官网中申请权限，需要等待几日。获取github中charting_library文件的权限。 2.数据配置的两种实现方式 – UDF/JSAPI&emsp;&emsp;tradingView数据配置的实现有两种方式，分别为UDF和JS API。UDF简单来说，该方法前端只需要一个接口，所有数据传输及配置全部由后端来进行，它不能供前端进行自定义配置。而JS API就是供开发者来进行自定义配置的，通常配合websocket实现数据耦合，本文也是借由websocket来进行数据动态更新。 3.UDF实现一个简单的示例&emsp;&emsp;首先将申请的权限文件 charting_library 和 datafeeds 文件夹放到react脚手架模板public文件夹下，然后index.html中引入： 123&lt;script src=\"charting_library/charting_library.min.js\"&gt;&lt;/script&gt;&lt;script src=\"datafeeds/udf/dist/polyfills.js\"&gt;&lt;/script&gt;&lt;script src=\"datafeeds/udf/dist/bundle.js\"&gt;&lt;/script&gt; &emsp;&emsp;接下来开始书写App.js中的内容 12345678910111213141516171819202122232425262728293031App.jsclass App extends Component { componentDidMount() { this.widgetInit() } widgetInit = () =&gt; { window.tvWidget = new window.TradingView.widget({ debug: false, fullscreen: true, symbol: 'BTCUSDT', interval: '15', container_id: \"App\", datafeed: new window.Datafeeds.UDFCompatibleDatafeed(\"https://demo_feed.tradingview.com\"), // 此处使用UDF数据，只需接入地址，所有数据配置全部由后端解决，前端只需引入地址即可 library_path: \"charting_library/\", locale: \"zh\", timezone: \"Asia/Shanghai\", disabled_features: [\"use_localstorage_for_settings\"], enabled_features: [\"study_templates\"], charts_storage_url: 'http://saveload.tradingview.com', charts_storage_api_version: \"1.1\", client_id: 'tradingview.com', user_id: 'public_user_id' }) } render() { return ( &lt;div id=\"App\"&gt;&lt;/div&gt; ) }} &emsp;&emsp;这样，UDF数据就会成功接入，实例项目可启动。 4.JS API + websocket实现一个简单的示例&emsp;&emsp;使用该方式自定义配置数据其实就是配置datafeed对象，该对象包括必填属性为: onready、resolveSymbol(解析商品信息)、getBars(获取历史数据)、subscribeBars(获取实时数据)。onready和resolveSymbol只需根据模板来配置即可，难点在于getBars和subscribeBars。下面将会呈现代码，重要的地方会做出标注解释，其它无关数据配置的属性可由官网教程慢慢查找即可。(websocket数据来自于某交易所网站，大家对参数不懂的可自行抓包理解即可)。 &emsp;&emsp;配置步骤:&emsp;&emsp; 1. 配置datafeed数据和websocket接口，将配置的对象赋值到state中的datafeed&emsp;&emsp; 2. 在setState()（异步方法）回调中触发widgetInit()方法，调用datafeed&emsp;&emsp; 3. 在getBars中会发送历史数据请求，websocket接收到信息作出相应数据处理，并触发getBars中的回调函数&emsp;&emsp; 4. 在subscribeBars中会发送实时数据请求，websocket接收到信息作出相应数据处理，并触发subscribeBars中的回调函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250App.jslet ws = nullconst config = { supports_search: false, supports_group_request: false, supported_resolutions : [\"1\", \"5\", \"15\", \"30\", \"60\", \"1D\", \"1W\"], supports_marks: true, supports_time: true, exchanges: [ { value: 'BCH', name: 'All Exchanges', desc: '' } ]}class App extends Component { constructor(props) { super(props) this.state = { datafeed: null, HCK: null, SUB: null, historyData: [], lastTime: 0 } } componentDidMount() { this.setDataFeed() this.webSocketInit() } // 需要等待setDataFeed动作结束 widgetInit = () =&gt; { let _this = this window.tvWidget = new window.TradingView.widget({ debug: false, fullscreen: true, symbol: 'BTCUSDT', interval: '15', container_id: \"App\", datafeed: _this.state.datafeed, library_path: \"charting_library/\", locale: \"zh\", timezone: \"Asia/Shanghai\", disabled_features: [\"use_localstorage_for_settings\"], enabled_features: [\"study_templates\"], charts_storage_url: 'http://saveload.tradingview.com', charts_storage_api_version: \"1.1\", client_id: 'tradingview.com', user_id: 'public_user_id' }) } // 设置配置数据 setDataFeed = () =&gt; { let datafeed = { onReady: cb =&gt; { setTimeout(() =&gt; { cb(config) }, 0); }, // 解析商品信息 resolveSymbol: (symbolName, onSymbolResolvedCallback, onResolveErrorCallback) =&gt; { var symbol_stub = { name: symbolName, ticker: symbolName, description: \"\", has_intraday: true, has_no_volume: false, minmov: 1, minmov2: 2, pricescale: 100000, session: \"24x7\", supported_resolutions: [\"1\", \"5\", \"15\", \"30\", \"60\", \"240\", \"1D\", \"1W\", \"1M\"], timezone: \"Asia/Shanghai\", type: \"stock\" } setTimeout(() =&gt; { onSymbolResolvedCallback(symbol_stub) }, 0) }, // 获取历史数据 getBars: (symbolInfo, resolution, from, to, onHistoryCallback, onErrorCallback, firstDataRequest) =&gt; { // 周期设置 -- 转换成秒 resolution = this.timeConversion(resolution) // 将回调函数抛出设置为HCK，这样便可以在此作用域外部使用该回调函数 this.setState({ HCK: onHistoryCallback }, () =&gt; { // setState()为异步方法，所以需要在回调中操作下面行为 let params = [symbolInfo.name, from, to, resolution] // 发送历史数据请求 this.sendKlineQueryReq(params) }) }, // 获取实时数据 subscribeBars: (symbolInfo, resolution, onRealtimeCallback, subscriberUID, onResetCacheNeededCallback) =&gt; { // 周期转换成秒 resolution = this.timeConversion(resolution) let params = [ symbolInfo.name, resolution ] // 同样的，抛出回调方法供在作用域外调用 this.setState({ SUB: onRealtimeCallback }, () =&gt; { // 发送实时数据请求 this.sendKlineSubReq(params) }) } } this.setState({ datafeed }, () =&gt;{ // 该方法需要datafeed数据设置完全后才能作用，否则会报错，setState()为异步方法，所以需要在它的回调中操作 this.widgetInit() }) } // websocket webSocketInit = () =&gt; { if ('WebSocket' in window) { if (ws === null) { ws = new WebSocket('wss://socket.coinex.com/') } ws.onopen = () =&gt; { console.log('连接成功') } ws.onmessage = res =&gt; { // 处理接收到的数据 this.WSHandler(JSON.parse(res.data)) } ws.onclose = () =&gt; { console.log('连接关闭') } } else { console.log('您的浏览器不支持websocket') } } // websocket接受数据,处理数据 WSHandler = res =&gt; { if (res.ttl === 400) { // 历史数据 let historyData = res.result.map(val =&gt; { return { time: Number(val[0]) * 1000, close: Number(val[2]), open: Number(val[1]), high: Number(val[3]), low: Number(val[4]), volume: Number(val[5]) } }) this.setState({ // 记录下最新时间用来对比数据更新时的最新时间 lastTime: historyData[historyData.length - 1].time, historyData }, () =&gt; { // 使用getBars中抛出的回调来继续执行到datafeed步骤中 if (historyData &amp;&amp; historyData.length) { // 此处需异步调用 -- 硬性规定 setTimeout(() =&gt; { this.state.HCK(historyData, { noData: false }) }, 0) } else { // 当historyData没有数据时需要设置noData属性为true,否则图标会处于无限加载状态 this.state.HCK(historyData, { noData: true }) } }) } if (res.method === 'kline.update') { // 实时数据 let bars = res.params.map(val =&gt; { return { time: Number(val[0]) * 1000, close: Number(val[2]), open: Number(val[1]), high: Number(val[3]), low: Number(val[4]), volume: Number(val[5]) } })[0] // 对比存储的最新时间和最新数据的时间大小来更新数据 if (this.state.lastTime - bars.time &lt;= 0) { setTimeout(() =&gt; { // 此处需异步调用 -- 硬性规定 // 调用subscribeBars中的回调来继续执行datafeed中的步骤 this.state.SUB(bars) }, 0) } } } // 将周期转换成秒 timeConversion = time =&gt; { switch(time) { case ('1M' || '1W' || '1D' || 'D'): return 86400 case '240': return 14400 case '120': return 7200 case '60': return 3600 case '30': return 1800 case '15': return 900 case '5': return 300 case '1': return 60 default: return 86400 } } // websocket发送请求 sendRequest = data =&gt; { if (ws.readyState === 1) { ws.send(JSON.stringify(data)) } else { ws.onopen = () =&gt; { ws.send(JSON.stringify(data)) } } } // 发送历史数据请求 sendKlineQueryReq = params =&gt; { let data = { id: 8, method: 'kline.query', params: params } this.sendRequest(data) } // 发送实时数据请求 sendKlineSubReq = params =&gt; { let data = { id: 9, method: 'kline.subscribe', params: params } this.sendRequest(data) } render() { return ( &lt;div id=\"App\"&gt; &lt;/div&gt; ); }} &emsp;以上是本人在研究过程中的大致过程，依照上面即可实现websocket的数据接入动态更新。","link":"/2019/07/21/tradingView/"}],"tags":[],"categories":[]}