{"pages":[],"posts":[{"title":"React Native简介","text":"传统的移动端开发模式 由于 AppStore 审核周期的限制，如何动态的更改 app 成为了永恒的话题。无论采用何种方式，我们的流程总是可以归结为以下三部曲：“从 Server 获取配置 –&gt; 解析 –&gt; 执行native代码”。 很多时候，我们自觉或者不自觉的利用 JSON 文件实现动态配置的效果，它的核心流程是： 1.通过 HTTP 请求获取 JSON 格式的配置文件。2.配置文件中标记了每一个元素的属性，比如位置，颜色，图片 URL 等。3.解析完 JSON 后，我们调用 Objective-C 的代码，完成 UI 控件的渲染。 通过这种方法，我们实现了在后台配置 app 的展示样式。从本质上来说，移动端和服务端约定了一套协议，但是协议内容严重依赖于应用内要展示的内容，不利于拓展。也就是说，如果业务要求频繁的增加或修改页面，这套协议很难应付。 最重要的是，JSON 只是一种数据交换的格式，说白了，我们就是在解析文本数据。这就意味着它只适合提供一些配置信息，而不方便提供逻辑信息。举个例子，我们从后台可以配置颜色，位置等信息，但如果想要控制 app 内的业务逻辑，就非常复杂了。 记住，我们只是在解析字符串，它完全不具备运行和调试的能力。 React 前端三大框架体系之一：React 背景传统的前端开发是这样的： 用 HTML 创建 DOM，构建整个网页的布局、结构 用 CSS 控制 DOM 的样式，比如字体、字号、颜色、居中等 用 JavaScript 接受用户事件，动态的操控 DOM 在这三者的配合下，几乎所有页面上的功能都能实现。但也有比较不爽地方，比如我想动态修改一个按钮的文字，我需要这样写： 123456&lt;button id=\"btn\"&gt;hello&lt;/button&gt;let btn = document.querySelector('#btn');btn.onclick = function () { this.innerText = 'world';} 可以看到，在 HTML 和 JavaScript 代码中，id 和 onclick 事件触发的函数必须完全对应，否则就无法正确的响应事件。如果想知道一个 HTML 标签会如何被响应，我们还得跑去 JavaScript 代码中查找，这种原始的配置方式让我觉得非常不爽。 初识 React随着 FaceBook 推出了 React 框架，这个问题得到了大幅度改善。我们可以把一组相关的 HTML 标签，也就是 app 内的 UI 控件，封装进一个组件(Component)中。 12345678910class App extends React.Component { handleClick = () =&gt; { console.log('你好'); } render () { return ( &lt;div onClick={ this.handleClick }&gt;hello world&lt;/div&gt; ) }} JavaScript代码里出现了HTML语法，使用了React独有的JSX语法，它可以将JSX标签转换为原生JS并创建DOM。开发者全程不需要操作DOM。 理解 ReactReact使用了新的概念：虚拟DOM。虚拟DOM是存在于内存中的JavaScript对象，它和DOM一一对应，并通过diff算法，最小化更新DOM，节省资源。 tree diff： React通过updateDepth对Virtual DOM树进行层级控制。 对树分层比较，两棵树 只对同一层次节点 进行比较。如果该节点不存在时，则该节点及其子节点会被完全删除，不会再进一步比较。 只需遍历一次，就能完成整棵DOM树的比较。 &emsp;&emsp;&emsp;&emsp;&emsp; React只会考虑同层级的改变，当出现跨层级的节点操作时(位置变化)，React只有创建节点和删除节点的操作。 component diff React对不同的组件间的比较，有三种策略 同一类型的两个组件，按原策略（层级比较）继续比较Virtual DOM树即可。 同一类型的两个组件，组件A变化为组件B时，可能Virtual DOM没有任何变化，如果知道这点（变换的过程中，Virtual DOM没有改变），可节省大量计算时间，所以 用户 可以通过 shouldComponentUpdate() 来判断是否需要 判断计算。 不同类型的组件，将一个（将被改变的）组件判断为dirty component（脏组件），从而替换 整个组件的所有节点。 注意：如果组件D和组件G的结构相似，但是 React判断是 不同类型的组件，则不会比较其结构，而是删除 组件D及其子节点，创建组件G及其子节点。 element diff 当节点处于同一层级时，diff提供三种节点操作：删除、插入、移动。对于同一层级的一组子节点，通过唯一id区分。 React Native","link":"/2019/11/24/react-native/"},{"title":"CSS3 transition","text":"trandition 过渡 transition是一个简写属性，是一个transition-property （定义过渡的属性的名称）以及 transition-duration （定义过渡属性的所需动画的时间）和 transition-timing-function （描述中间值如何计算的） 以及 transition-delay （描述过渡效果开始作用之前需要等待的时间）。 transition-property transition-property 定义过渡属性的名称 即指定引用过渡属性的名称。 其实现css如下： 12345678910111213&lt;div id=\"transition-property-style\"&gt;&lt;/div&gt;&lt;style&gt; #transition-property-style div { width: 300px; height: 200px; background-color: teal; } #transition-property-style:hover { background: blue; transition-property: background; }&lt;/style&gt; transition-duration transition-duration这是一个过渡时间的设置。 设置过渡的时间为2s。 其实现css如下： 1234567891011121314&lt;div id=\"transition-property-duration-style\"&gt;&lt;/div&gt;&lt;style&gt; #transition-property-style div { width: 300px; height: 200px; background-color: teal; } #transition-property-style:hover { background: blue; transition-property: background; transition-duration: 2s; }&lt;/style&gt; transition-timing-function 该属性用于描述属性的中间值。即该两个状态变化的过渡曲线。其取值是一个三次方的贝塞尔曲线的值。贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线。 其实现css如下： 12345678910111213141516171819&lt;div id=\"transition-property-timming-function-style\"&gt;&lt;/div&gt;&lt;style&gt; #transition-property-timming-function-style { width: 200px; height: 200px; margin: auto; background-color: #698771; transition-property: width; transition-duration: 3s; trasition-timing-function: cubic-bezier(0.645, 0.045, 0.355, 1); } #transition-property-timming-function-style:hover { width: 100%; transition-property: width; transition-duration: 2s; transition-timing-function: cubic-bezier(0.645, 0.045, 0.355, 1); }&lt;/style&gt; cubic-bezier为一个时序功能的类，该类有四个参数。分别有四个点，对应于三次方的贝塞尔曲线。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; p0和p1为起点和终点，其中p0和p1两个值都是固定的分别为(0,0)和(1， 1)这是两个起始值和终止值，其中传入该参数的为p1和p2的值，（p1和p2的值只能在[0,1]的范围内，否则css将会忽视该属性的值） 一些定义的关键字linear一个一次函数，经过原点恒定的速率运动。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ease动画开始缓慢，急剧加速，然后逐渐减慢。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ease-in动画开始缓慢，然后逐渐加速直到结束，此时它突然停止。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ease-in-out动画开始缓慢，加速，然后减速到最后。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ease-out动画突然开始，然后逐渐减慢到最后。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; step-start动画会立即跳转到最终状态，直到结束。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; step-end动画保持其初始状态直到结束，此时它直接跳转到最终状态。 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; transition-delay 规定过渡效果开始作用之前需要等待的时间。 其实现css如下： 123456789101112131415161718192021&lt;div id=\"transition-property-delay-style\"&gt;&lt;/div&gt;&lt;style&gt; #transition-property-delay-style { width: 200px; height: 200px; margin: auto; background-color: #698771; transition-property: width; transition-duration: 3s; trasition-timing-function: cubic-bezier(0.645, 0.045, 0.355, 1); transition-delay: 1s; } #transition-property-delay-style:hover { width: 100%; transition-property: width; transition-duration: 2s; transition-timing-function: cubic-bezier(0.645, 0.045, 0.355, 1); transition-delay: 1s; }&lt;/style&gt; 过渡总写实现一个简单的过渡组合： 123456789101112131415161718192021&lt;div id=\"transition-property-all-style\"&gt;&lt;/div&gt;&lt;style&gt; #transition-property-all-style { width: 100px; height: 70px; background: skyblue; border-radius: 50%; margin: auto; transition: 2s all linear; } #transition-property-all-style:hover { width: 200px; height: 140px; background: green; border-radius: 50%; margin: auto; transform: rotateY(720deg); transition: 2s all linear; }&lt;/style&gt; /* property */ #transition-property-style { width: 300px; height: 200px; background-color: teal; } #transition-property-style:hover { background: blue; transition-property: background; } /* duration */ #transition-property-duration-style { width: 300px; height: 200px; background-color: teal; } #transition-property-duration-style:hover { background: blue; transition-property: background; transition-duration: 2s; } /* function */ #transition-property-timming-function-style { width: 200px; height: 200px; margin: auto; background-color: #698771; transition-property: width; transition-duration: 3s; trasition-timing-function: cubic-bezier(0.645, 0.045, 0.355, 1); } #transition-property-timming-function-style:hover { width: 100%; transition-property: width; transition-duration: 2s; transition-timing-function: cubic-bezier(0.645, 0.045, 0.355, 1); } /* delay */ #transition-property-delay-style { width: 200px; height: 200px; margin: auto; background-color: #698771; transition-property: width; transition-duration: 3s; trasition-timing-function: cubic-bezier(0.645, 0.045, 0.355, 1); transition-delay: 1s; } #transition-property-delay-style:hover { width: 100%; transition-property: width; transition-duration: 2s; transition-timing-function: cubic-bezier(0.645, 0.045, 0.355, 1); transition-delay: 1s; } /* 复合写法 */ #transition-property-all-style { width: 100px; height: 70px; background: skyblue; border-radius: 50%; margin: auto; transition: 2s all linear; } #transition-property-all-style:hover { width: 200px; height: 140px; background: green; border-radius: 50%; margin: auto; transform: rotateY(720deg); transition: 2s all linear; }","link":"/2019/12/23/transition/"},{"title":"react中如何自定义配置tradingView数据","text":"&emsp;&emsp;tradingView（以下简称为Tv）是当下交易所实现K线功能不可或缺的工具。但是其官方教程文档写的不够详细，导致本人在进行自定义数据配置时遇到一些困难。在此，我将该过程中的难点分享出来，希望大家看完能有效迅速的将其应用到你的项目中。完整实例地址 1.获取tradingView权限文件&emsp;&emsp;在官网中申请权限，需要等待几日。获取github中charting_library文件的权限。 2.数据配置的两种实现方式 – UDF/JSAPI&emsp;&emsp;tradingView数据配置的实现有两种方式，分别为UDF和JS API。UDF简单来说，该方法前端只需要一个接口，所有数据传输及配置全部由后端来进行，它不能供前端进行自定义配置。而JS API就是供开发者来进行自定义配置的，通常配合websocket实现数据耦合，本文也是借由websocket来进行数据动态更新。 3.UDF实现一个简单的示例&emsp;&emsp;首先将申请的权限文件 charting_library 和 datafeeds 文件夹放到react脚手架模板public文件夹下，然后index.html中引入： 123&lt;script src=\"charting_library/charting_library.min.js\"&gt;&lt;/script&gt;&lt;script src=\"datafeeds/udf/dist/polyfills.js\"&gt;&lt;/script&gt;&lt;script src=\"datafeeds/udf/dist/bundle.js\"&gt;&lt;/script&gt; &emsp;&emsp;接下来开始书写App.js中的内容 12345678910111213141516171819202122232425262728293031App.jsclass App extends Component { componentDidMount() { this.widgetInit() } widgetInit = () =&gt; { window.tvWidget = new window.TradingView.widget({ debug: false, fullscreen: true, symbol: 'BTCUSDT', interval: '15', container_id: \"App\", datafeed: new window.Datafeeds.UDFCompatibleDatafeed(\"https://demo_feed.tradingview.com\"), // 此处使用UDF数据，只需接入地址，所有数据配置全部由后端解决，前端只需引入地址即可 library_path: \"charting_library/\", locale: \"zh\", timezone: \"Asia/Shanghai\", disabled_features: [\"use_localstorage_for_settings\"], enabled_features: [\"study_templates\"], charts_storage_url: 'http://saveload.tradingview.com', charts_storage_api_version: \"1.1\", client_id: 'tradingview.com', user_id: 'public_user_id' }) } render() { return ( &lt;div id=\"App\"&gt;&lt;/div&gt; ) }} &emsp;&emsp;这样，UDF数据就会成功接入，实例项目可启动。 4.JS API + websocket实现一个简单的示例&emsp;&emsp;使用该方式自定义配置数据其实就是配置datafeed对象，该对象包括必填属性为: onready、resolveSymbol(解析商品信息)、getBars(获取历史数据)、subscribeBars(获取实时数据)。onready和resolveSymbol只需根据模板来配置即可，难点在于getBars和subscribeBars。下面将会呈现代码，重要的地方会做出标注解释，其它无关数据配置的属性可由官网教程慢慢查找即可。(websocket数据来自于某交易所网站，大家对参数不懂的可自行抓包理解即可)。 &emsp;&emsp;配置步骤:&emsp;&emsp; 1. 配置datafeed数据和websocket接口，将配置的对象赋值到state中的datafeed&emsp;&emsp; 2. 在setState()（异步方法）回调中触发widgetInit()方法，调用datafeed&emsp;&emsp; 3. 在getBars中会发送历史数据请求，websocket接收到信息作出相应数据处理，并触发getBars中的回调函数&emsp;&emsp; 4. 在subscribeBars中会发送实时数据请求，websocket接收到信息作出相应数据处理，并触发subscribeBars中的回调函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250App.jslet ws = nullconst config = { supports_search: false, supports_group_request: false, supported_resolutions : [\"1\", \"5\", \"15\", \"30\", \"60\", \"1D\", \"1W\"], supports_marks: true, supports_time: true, exchanges: [ { value: 'BCH', name: 'All Exchanges', desc: '' } ]}class App extends Component { constructor(props) { super(props) this.state = { datafeed: null, HCK: null, SUB: null, historyData: [], lastTime: 0 } } componentDidMount() { this.setDataFeed() this.webSocketInit() } // 需要等待setDataFeed动作结束 widgetInit = () =&gt; { let _this = this window.tvWidget = new window.TradingView.widget({ debug: false, fullscreen: true, symbol: 'BTCUSDT', interval: '15', container_id: \"App\", datafeed: _this.state.datafeed, library_path: \"charting_library/\", locale: \"zh\", timezone: \"Asia/Shanghai\", disabled_features: [\"use_localstorage_for_settings\"], enabled_features: [\"study_templates\"], charts_storage_url: 'http://saveload.tradingview.com', charts_storage_api_version: \"1.1\", client_id: 'tradingview.com', user_id: 'public_user_id' }) } // 设置配置数据 setDataFeed = () =&gt; { let datafeed = { onReady: cb =&gt; { setTimeout(() =&gt; { cb(config) }, 0); }, // 解析商品信息 resolveSymbol: (symbolName, onSymbolResolvedCallback, onResolveErrorCallback) =&gt; { var symbol_stub = { name: symbolName, ticker: symbolName, description: \"\", has_intraday: true, has_no_volume: false, minmov: 1, minmov2: 2, pricescale: 100000, session: \"24x7\", supported_resolutions: [\"1\", \"5\", \"15\", \"30\", \"60\", \"240\", \"1D\", \"1W\", \"1M\"], timezone: \"Asia/Shanghai\", type: \"stock\" } setTimeout(() =&gt; { onSymbolResolvedCallback(symbol_stub) }, 0) }, // 获取历史数据 getBars: (symbolInfo, resolution, from, to, onHistoryCallback, onErrorCallback, firstDataRequest) =&gt; { // 周期设置 -- 转换成秒 resolution = this.timeConversion(resolution) // 将回调函数抛出设置为HCK，这样便可以在此作用域外部使用该回调函数 this.setState({ HCK: onHistoryCallback }, () =&gt; { // setState()为异步方法，所以需要在回调中操作下面行为 let params = [symbolInfo.name, from, to, resolution] // 发送历史数据请求 this.sendKlineQueryReq(params) }) }, // 获取实时数据 subscribeBars: (symbolInfo, resolution, onRealtimeCallback, subscriberUID, onResetCacheNeededCallback) =&gt; { // 周期转换成秒 resolution = this.timeConversion(resolution) let params = [ symbolInfo.name, resolution ] // 同样的，抛出回调方法供在作用域外调用 this.setState({ SUB: onRealtimeCallback }, () =&gt; { // 发送实时数据请求 this.sendKlineSubReq(params) }) } } this.setState({ datafeed }, () =&gt;{ // 该方法需要datafeed数据设置完全后才能作用，否则会报错，setState()为异步方法，所以需要在它的回调中操作 this.widgetInit() }) } // websocket webSocketInit = () =&gt; { if ('WebSocket' in window) { if (ws === null) { ws = new WebSocket('wss://socket.coinex.com/') } ws.onopen = () =&gt; { console.log('连接成功') } ws.onmessage = res =&gt; { // 处理接收到的数据 this.WSHandler(JSON.parse(res.data)) } ws.onclose = () =&gt; { console.log('连接关闭') } } else { console.log('您的浏览器不支持websocket') } } // websocket接受数据,处理数据 WSHandler = res =&gt; { if (res.ttl === 400) { // 历史数据 let historyData = res.result.map(val =&gt; { return { time: Number(val[0]) * 1000, close: Number(val[2]), open: Number(val[1]), high: Number(val[3]), low: Number(val[4]), volume: Number(val[5]) } }) this.setState({ // 记录下最新时间用来对比数据更新时的最新时间 lastTime: historyData[historyData.length - 1].time, historyData }, () =&gt; { // 使用getBars中抛出的回调来继续执行到datafeed步骤中 if (historyData &amp;&amp; historyData.length) { // 此处需异步调用 -- 硬性规定 setTimeout(() =&gt; { this.state.HCK(historyData, { noData: false }) }, 0) } else { // 当historyData没有数据时需要设置noData属性为true,否则图标会处于无限加载状态 this.state.HCK(historyData, { noData: true }) } }) } if (res.method === 'kline.update') { // 实时数据 let bars = res.params.map(val =&gt; { return { time: Number(val[0]) * 1000, close: Number(val[2]), open: Number(val[1]), high: Number(val[3]), low: Number(val[4]), volume: Number(val[5]) } })[0] // 对比存储的最新时间和最新数据的时间大小来更新数据 if (this.state.lastTime - bars.time &lt;= 0) { setTimeout(() =&gt; { // 此处需异步调用 -- 硬性规定 // 调用subscribeBars中的回调来继续执行datafeed中的步骤 this.state.SUB(bars) }, 0) } } } // 将周期转换成秒 timeConversion = time =&gt; { switch(time) { case ('1M' || '1W' || '1D' || 'D'): return 86400 case '240': return 14400 case '120': return 7200 case '60': return 3600 case '30': return 1800 case '15': return 900 case '5': return 300 case '1': return 60 default: return 86400 } } // websocket发送请求 sendRequest = data =&gt; { if (ws.readyState === 1) { ws.send(JSON.stringify(data)) } else { ws.onopen = () =&gt; { ws.send(JSON.stringify(data)) } } } // 发送历史数据请求 sendKlineQueryReq = params =&gt; { let data = { id: 8, method: 'kline.query', params: params } this.sendRequest(data) } // 发送实时数据请求 sendKlineSubReq = params =&gt; { let data = { id: 9, method: 'kline.subscribe', params: params } this.sendRequest(data) } render() { return ( &lt;div id=\"App\"&gt; &lt;/div&gt; ); }} &emsp;以上是本人在研究过程中的大致过程，依照上面即可实现websocket的数据接入动态更新。","link":"/2019/07/21/tradingView/"},{"title":"CSS3 animation","text":"虽然 transition 已经提供了很棒的动画效果了，但是我们只能够控制从一个状态到达另外一个状态，没法来控制多个状态的不断变化，而 animation 而帮助我们实现了这一点。使用 animation 的前提是我们需要先使用 @keyframes 来定义一个动画效果，@keyframes 定义的规则可以用来控制动画过程中的各个状态的情况，语法大抵是这个样子： 12345678910@keyframes name { from { left: 0; top: 0; } to { left: 100%; top: 100%; }} @keyframes 关键词后跟动画的名字，然后是一个块，块中有动画进度的各个选择器，选择器后的块则依旧是我们常见的各个 CSS 样式属性。不是所有的属性都可以有动画效果，MDN 维护了一份 CSS 动画的属性列表 可供参考。 注：通常来说，多个状态下的相同属性的值应该是可以取到它们的中间值的，例如 left 从 0% 到 100%，如果没法取到中间值，如 height 从 auto 到 100px，有可能出现奇怪的一些状况，并且不同浏览器对此的处理也不尽相同，所以请尽量避免这种情况。 animation-name 你需要的动画效果的 @keyframes 的名字。 animation-delay 动画延迟的时间。 animtaion-duration 动画持续的时间。 animation-direction 动画的一个方向控制。默认是 normal，如果是上述的 left 从 0% 到 100%，那么默认是从左到右。如果这个值是 reverse，那么便是从右到左。 animation-fill-mode 这个属性用来控制动画前后，@keyframes 中提供的 CSS 属性如何应用到元素上。默认值是 none，还有其他三个选择：forwards，backwards，both animation-timing-function 动画变化轨迹的算法。 animation-iteration-count 动画循环次数，如果是 infinite 则无限次。有趣的是，支持小数，即 0.5 表示动画执行到一半。 animation-play-state 动画执行的状态，两个值 running 或者 paused，可以用来控制动画是否执行。 animation优先级记得 CSS 中的层叠概念么，优先级高的属性会覆盖优先级低的属性，当 animation 应用到元素中时，动画运行过程中，@keyframes 声明的 CSS 属性优先级最高，比行内声明 !important 的样式还要高。现在浏览器的实现是这样子的，但是标准文档中的说法应该是可以被 !important 声明的属性所覆盖。 多个动画的顺序由于 animation-name 是可以指定多个动画效果的，所以这里便会出现动画的一个顺序问题。后指定的动画会覆盖掉前边的，例如： 1234#colors { animation-name: red, green, blue; /* 假设这些 keyframe 都是修改 color 这个属性 */ animation-duration: 5s, 4s, 3s;} 上述代码的动画效果会是这样：前 3 秒是 blue，然后接着 1 秒是 green，最后 1 秒是 red。整个覆盖的规则是比较简单的。 display 的影响如果一个元素的 display 设置为 none，那么在它或者它的子元素上的动画效果便会停止，而重新设置 display 为可见后，动画效果会重新重头开始执行。 demoslideTop&nbsp;隐藏 hello world slideLeft 实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;button id=\"btn\"&gt;slideTop&lt;/button&gt;&amp;nbsp;&lt;button id=\"hide\"&gt;隐藏&lt;/button&gt;&lt;div id=\"animation\"&gt;hello world&lt;/div&gt;&lt;button id=\"btn2\"&gt;slideLeft&lt;/button&gt;&lt;div id=\"welcome\"&gt;&lt;/div&gt;&lt;script&gt; let btn = document.querySelector('#btn'); let btn2 = document.querySelector('#btn2'); let ani = document.querySelector('#animation'); let wel = document.querySelector('#welcome'); let hide = document.querySelector('#hide'); btn.onclick = function () { if (ani.style.display === 'block') { ani.style.display = 'none'; setTimeout(() =&gt; { ani.style.display = 'block'; }, 0) } else { ani.style.display = 'block'; } } hide.onclick = function () { ani.style.display = 'none'; } btn2.onclick = function () { if (wel.style.display === 'block') { wel.style.display = 'none'; setTimeout(() =&gt; { wel.style.display = 'block'; }, 0) } else { wel.style.display = 'block'; } }&lt;/script&gt;&lt;style&gt; #animation { animation: fadeIn 0.5s; color: skyblue; display: none; } @keyframes fadeIn { from { transform: translateY(-20px); } to { transform: translateY(0); } } #welcome { animation: slideLeft 4s; background: red; display: none; width: 90px; height: 50px; overflow: hidden; } @keyframes slideLeft { 0% { transform: translateY(-20px); opacity: 0; } 20% { opacity: 1; transform: translateY(0); } 21% { transform: rotateY(0); } 39% { transform: rotateY(360deg); } 40% { margin-left: 0px; transform: rotateZ(0deg); transform-origin: center; } 100% { transform: rotateZ(360deg); margin-left: 360px; transform-origin: center; } }&lt;/style&gt; let btn = document.querySelector('#btn'); let btn2 = document.querySelector('#btn2'); let ani = document.querySelector('#animation'); let wel = document.querySelector('#welcome'); let hide = document.querySelector('#hide'); btn.onclick = function () { if (ani.style.display === 'block') { ani.style.display = 'none'; setTimeout(() => { ani.style.display = 'block'; }, 0) } else { ani.style.display = 'block'; } } hide.onclick = function () { ani.style.display = 'none'; } btn2.onclick = function () { if (wel.style.display === 'block') { wel.style.display = 'none'; setTimeout(() => { wel.style.display = 'block'; }, 0) } else { wel.style.display = 'block'; } } #animation { animation: fadeIn 0.5s; color: skyblue; display: none; } @keyframes fadeIn { from { transform: translateY(-20px); } to { transform: translateY(0); } } #welcome { animation: slideLeft 4s; background: red; display: none; width: 90px; height: 50px; overflow: hidden; } @keyframes slideLeft { 0% { transform: translateY(-20px); opacity: 0; } 20% { opacity: 1; transform: translateY(0); } 21% { transform: rotateY(0); } 39% { transform: rotateY(360deg); } 40% { margin-left: 0px; transform: rotateZ(0deg); transform-origin: center; } 100% { transform: rotateZ(360deg); margin-left: 360px; transform-origin: center; } }","link":"/2019/12/24/animation/"}],"tags":[],"categories":[]}